/*******************************************************************************
    Copyright (c) 2011, Yahoo! Inc.
    All rights reserved.

    Redistribution and use of this software in source and binary forms, 
    with or without modification, are permitted provided that the following 
    conditions are met:

    * Redistributions of source code must retain the above
      copyright notice, this list of conditions and the
      following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the
      following disclaimer in the documentation and/or other
      materials provided with the distribution.

    * Neither the name of Yahoo! Inc. nor the names of its
      contributors may be used to endorse or promote products
      derived from this software without specific prior
      written permission of Yahoo! Inc.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS 
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    The Initial Developer of the Original Code is Shravan Narayanamurthy.
******************************************************************************/
// **********************************************************************
//
// Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

// Ice version 3.4.1

// <auto-generated>
//
// Generated from file `DistributedMap.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#include <DistributedMap.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

static const ::std::string __GlobalTable__DistributedMap__put_name = "put";

static const ::std::string __GlobalTable__DistributedMap__set_name = "set";

static const ::std::string __GlobalTable__DistributedMap__remove_name = "remove";

static const ::std::string __GlobalTable__DistributedMap__putNget_name = "putNget";

static const ::std::string __GlobalTable__DistributedMap__get_name = "get";

static const ::std::string __GlobalTable__DistributedMap__waitForAllClients_name = "waitForAllClients";

::Ice::Object* IceInternal::upCast(::GlobalTable::DistributedMap* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::GlobalTable::DistributedMap* p) { return p; }

void
GlobalTable::__read(::IceInternal::BasicStream* __is, ::GlobalTable::DistributedMapPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::GlobalTable::DistributedMap;
        v->__copyFrom(proxy);
    }
}

IceAsync::GlobalTable::AMD_DistributedMap_putNget::AMD_DistributedMap_putNget(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::GlobalTable::AMD_DistributedMap_putNget::ice_response(const ::std::string& counts)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = this->__os();
            __os->write(counts);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response(true);
    }
}

IceAsync::GlobalTable::AMD_DistributedMap_waitForAllClients::AMD_DistributedMap_waitForAllClients(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::GlobalTable::AMD_DistributedMap_waitForAllClients::ice_response()
{
    if(__validateResponse(true))
    {
        __response(true);
    }
}

void
IceProxy::GlobalTable::DistributedMap::put(const ::std::string& s, const ::std::string& delta, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::GlobalTable::DistributedMap* __del = dynamic_cast< ::IceDelegate::GlobalTable::DistributedMap*>(__delBase.get());
            __del->put(s, delta, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::GlobalTable::DistributedMap::begin_put(const ::std::string& s, const ::std::string& delta, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __GlobalTable__DistributedMap__put_name, __del, __cookie);
    try
    {
        __result->__prepare(__GlobalTable__DistributedMap__put_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(s);
        __os->write(delta);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::GlobalTable::DistributedMap::end_put(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __GlobalTable__DistributedMap__put_name);
}

void
IceProxy::GlobalTable::DistributedMap::set(const ::std::string& s, const ::std::string& counts, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::GlobalTable::DistributedMap* __del = dynamic_cast< ::IceDelegate::GlobalTable::DistributedMap*>(__delBase.get());
            __del->set(s, counts, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::GlobalTable::DistributedMap::begin_set(const ::std::string& s, const ::std::string& counts, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __GlobalTable__DistributedMap__set_name, __del, __cookie);
    try
    {
        __result->__prepare(__GlobalTable__DistributedMap__set_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(s);
        __os->write(counts);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::GlobalTable::DistributedMap::end_set(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __GlobalTable__DistributedMap__set_name);
}

bool
IceProxy::GlobalTable::DistributedMap::remove(const ::std::string& s, ::std::string& counts, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__GlobalTable__DistributedMap__remove_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::GlobalTable::DistributedMap* __del = dynamic_cast< ::IceDelegate::GlobalTable::DistributedMap*>(__delBase.get());
            return __del->remove(s, counts, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::GlobalTable::DistributedMap::begin_remove(const ::std::string& s, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__GlobalTable__DistributedMap__remove_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __GlobalTable__DistributedMap__remove_name, __del, __cookie);
    try
    {
        __result->__prepare(__GlobalTable__DistributedMap__remove_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(s);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::GlobalTable::DistributedMap::end_remove(::std::string& counts, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __GlobalTable__DistributedMap__remove_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(counts);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::GlobalTable::DistributedMap::putNget(const ::std::string& s, const ::std::string& delta, ::std::string& counts, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__GlobalTable__DistributedMap__putNget_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::GlobalTable::DistributedMap* __del = dynamic_cast< ::IceDelegate::GlobalTable::DistributedMap*>(__delBase.get());
            __del->putNget(s, delta, counts, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::GlobalTable::DistributedMap::begin_putNget(const ::std::string& s, const ::std::string& delta, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__GlobalTable__DistributedMap__putNget_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __GlobalTable__DistributedMap__putNget_name, __del, __cookie);
    try
    {
        __result->__prepare(__GlobalTable__DistributedMap__putNget_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(s);
        __os->write(delta);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::GlobalTable::DistributedMap::end_putNget(::std::string& counts, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __GlobalTable__DistributedMap__putNget_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(counts);
    __is->endReadEncaps();
}

bool
IceProxy::GlobalTable::DistributedMap::get(const ::std::string& s, ::std::string& counts, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__GlobalTable__DistributedMap__get_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::GlobalTable::DistributedMap* __del = dynamic_cast< ::IceDelegate::GlobalTable::DistributedMap*>(__delBase.get());
            return __del->get(s, counts, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::GlobalTable::DistributedMap::begin_get(const ::std::string& s, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__GlobalTable__DistributedMap__get_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __GlobalTable__DistributedMap__get_name, __del, __cookie);
    try
    {
        __result->__prepare(__GlobalTable__DistributedMap__get_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(s);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::GlobalTable::DistributedMap::end_get(::std::string& counts, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __GlobalTable__DistributedMap__get_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(counts);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::GlobalTable::DistributedMap::waitForAllClients(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::GlobalTable::DistributedMap* __del = dynamic_cast< ::IceDelegate::GlobalTable::DistributedMap*>(__delBase.get());
            __del->waitForAllClients(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::GlobalTable::DistributedMap::begin_waitForAllClients(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __GlobalTable__DistributedMap__waitForAllClients_name, __del, __cookie);
    try
    {
        __result->__prepare(__GlobalTable__DistributedMap__waitForAllClients_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::GlobalTable::DistributedMap::end_waitForAllClients(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __GlobalTable__DistributedMap__waitForAllClients_name);
}

const ::std::string&
IceProxy::GlobalTable::DistributedMap::ice_staticId()
{
    return ::GlobalTable::DistributedMap::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::GlobalTable::DistributedMap::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::GlobalTable::DistributedMap);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::GlobalTable::DistributedMap::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::GlobalTable::DistributedMap);
}

::IceProxy::Ice::Object*
IceProxy::GlobalTable::DistributedMap::__newInstance() const
{
    return new DistributedMap;
}

void
IceDelegateM::GlobalTable::DistributedMap::put(const ::std::string& s, const ::std::string& delta, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __GlobalTable__DistributedMap__put_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(s);
        __os->write(delta);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::GlobalTable::DistributedMap::set(const ::std::string& s, const ::std::string& counts, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __GlobalTable__DistributedMap__set_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(s);
        __os->write(counts);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::GlobalTable::DistributedMap::remove(const ::std::string& s, ::std::string& counts, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __GlobalTable__DistributedMap__remove_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(s);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(counts);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::GlobalTable::DistributedMap::putNget(const ::std::string& s, const ::std::string& delta, ::std::string& counts, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __GlobalTable__DistributedMap__putNget_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(s);
        __os->write(delta);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(counts);
        __is->endReadEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::GlobalTable::DistributedMap::get(const ::std::string& s, ::std::string& counts, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __GlobalTable__DistributedMap__get_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(s);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(counts);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::GlobalTable::DistributedMap::waitForAllClients(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __GlobalTable__DistributedMap__waitForAllClients_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateD::GlobalTable::DistributedMap::put(const ::std::string& s, const ::std::string& delta, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& s, const ::std::string& delta, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_s(s),
            _m_delta(delta)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::GlobalTable::DistributedMap* servant = dynamic_cast< ::GlobalTable::DistributedMap*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->put(_m_s, _m_delta, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_s;
        const ::std::string& _m_delta;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __GlobalTable__DistributedMap__put_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(s, delta, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::GlobalTable::DistributedMap::set(const ::std::string& s, const ::std::string& counts, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& s, const ::std::string& counts, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_s(s),
            _m_counts(counts)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::GlobalTable::DistributedMap* servant = dynamic_cast< ::GlobalTable::DistributedMap*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->set(_m_s, _m_counts, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_s;
        const ::std::string& _m_counts;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __GlobalTable__DistributedMap__set_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(s, counts, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::GlobalTable::DistributedMap::remove(const ::std::string& s, ::std::string& counts, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::std::string& s, ::std::string& counts, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_s(s),
            _m_counts(counts)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::GlobalTable::DistributedMap* servant = dynamic_cast< ::GlobalTable::DistributedMap*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->remove(_m_s, _m_counts, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        const ::std::string& _m_s;
        ::std::string& _m_counts;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __GlobalTable__DistributedMap__remove_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, s, counts, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::GlobalTable::DistributedMap::putNget(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

bool
IceDelegateD::GlobalTable::DistributedMap::get(const ::std::string& s, ::std::string& counts, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::std::string& s, ::std::string& counts, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_s(s),
            _m_counts(counts)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::GlobalTable::DistributedMap* servant = dynamic_cast< ::GlobalTable::DistributedMap*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->get(_m_s, _m_counts, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        const ::std::string& _m_s;
        ::std::string& _m_counts;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __GlobalTable__DistributedMap__get_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, s, counts, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::GlobalTable::DistributedMap::waitForAllClients(const ::Ice::Context*)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Ice::ObjectPtr
GlobalTable::DistributedMap::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __GlobalTable__DistributedMap_ids[2] =
{
    "::GlobalTable::DistributedMap",
    "::Ice::Object"
};

bool
GlobalTable::DistributedMap::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__GlobalTable__DistributedMap_ids, __GlobalTable__DistributedMap_ids + 2, _s);
}

::std::vector< ::std::string>
GlobalTable::DistributedMap::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__GlobalTable__DistributedMap_ids[0], &__GlobalTable__DistributedMap_ids[2]);
}

const ::std::string&
GlobalTable::DistributedMap::ice_id(const ::Ice::Current&) const
{
    return __GlobalTable__DistributedMap_ids[0];
}

const ::std::string&
GlobalTable::DistributedMap::ice_staticId()
{
    return __GlobalTable__DistributedMap_ids[0];
}

::Ice::DispatchStatus
GlobalTable::DistributedMap::___put(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string s;
    ::std::string delta;
    __is->read(s);
    __is->read(delta);
    __is->endReadEncaps();
    put(s, delta, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
GlobalTable::DistributedMap::___set(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string s;
    ::std::string counts;
    __is->read(s);
    __is->read(counts);
    __is->endReadEncaps();
    set(s, counts, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
GlobalTable::DistributedMap::___remove(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string s;
    __is->read(s);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string counts;
    bool __ret = remove(s, counts, __current);
    __os->write(counts);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
GlobalTable::DistributedMap::___putNget(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string s;
    ::std::string delta;
    __is->read(s);
    __is->read(delta);
    __is->endReadEncaps();
    ::GlobalTable::AMD_DistributedMap_putNgetPtr __cb = new IceAsync::GlobalTable::AMD_DistributedMap_putNget(__inS);
    try
    {
        putNget_async(__cb, s, delta, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
GlobalTable::DistributedMap::___get(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string s;
    __is->read(s);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string counts;
    bool __ret = get(s, counts, __current);
    __os->write(counts);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
GlobalTable::DistributedMap::___waitForAllClients(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::GlobalTable::AMD_DistributedMap_waitForAllClientsPtr __cb = new IceAsync::GlobalTable::AMD_DistributedMap_waitForAllClients(__inS);
    try
    {
        waitForAllClients_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

static ::std::string __GlobalTable__DistributedMap_all[] =
{
    "get",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "put",
    "putNget",
    "remove",
    "set",
    "waitForAllClients"
};

::Ice::DispatchStatus
GlobalTable::DistributedMap::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__GlobalTable__DistributedMap_all, __GlobalTable__DistributedMap_all + 10, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __GlobalTable__DistributedMap_all)
    {
        case 0:
        {
            return ___get(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
        case 5:
        {
            return ___put(in, current);
        }
        case 6:
        {
            return ___putNget(in, current);
        }
        case 7:
        {
            return ___remove(in, current);
        }
        case 8:
        {
            return ___set(in, current);
        }
        case 9:
        {
            return ___waitForAllClients(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
GlobalTable::DistributedMap::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
GlobalTable::DistributedMap::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
GlobalTable::DistributedMap::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type GlobalTable::DistributedMap was not generated with stream support";
    throw ex;
}

void
GlobalTable::DistributedMap::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type GlobalTable::DistributedMap was not generated with stream support";
    throw ex;
}
#endif

void 
GlobalTable::__patch__DistributedMapPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::GlobalTable::DistributedMapPtr* p = static_cast< ::GlobalTable::DistributedMapPtr*>(__addr);
    assert(p);
    *p = ::GlobalTable::DistributedMapPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::GlobalTable::DistributedMap::ice_staticId(), v->ice_id());
    }
}
