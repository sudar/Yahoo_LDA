<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Y!LDA: Y!LDA Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="architecture">Y!LDA Architecture </a></h1><h2><a class="anchor" id="intro">
Introduction</a></h2>
<p>Please refer the Main Page for an introduction</p>
<h2><a class="anchor" id="goals">
Goals</a></h2>
<p>The approach to do topic modelling is to have a graphical model representing the generative assumptions the user has about the corpus. A graphical model is a probabilistic model representing the joint distribution of the random variables involved with a graph denoting the conditional independence assumptions amongst them. Solving the model is to infer the parameters of the model by processing the actual data. Doing this inference is the hardest part of the approach.</p>
<h3><a class="anchor" id="new_models">
Adding new Models</a></h3>
<p>There are a lot of variations on the basic LDA model and with each variation the inferencing logic changes. The parameters, the sufficient statistics that need to be maintained everything will be slightly different. One of the main goals of this framework is to make the job of adding new models simpler.</p>
<h3><a class="anchor" id="infrastructure">
Common Infrastructure</a></h3>
<p>One task that is mostly common across multiple models is the infrastructure needed to store documents, load them, create a pipeline that can optimally utilize multi-core parallelism. In the framework we aim to standardize on proven infrastructure that is known to provide efficient implementations so that the model writer just worries about adding only the parts that are relevant for doing the inference</p>
<h3><a class="anchor" id="scalability">
Scalability</a></h3>
<p>Another main aspect of this framework is to substantially increase the scale of the state of the art by utilizing parallelism both multi-core and multi-machine.</p>
<h2><a class="anchor" id="components">
Main components of the System</a></h2>
<p>Y!LDA uses the Gibbs sampling approach popularized by <a href="http://dx.doi.org/10.1073%2Fpnas.0307752101">Collapsed Gibbs Sampling</a>. There are four main components in this approach: </p>
<ol>
<li>
<b><a class="el" href="class_model.html">Model</a>:</b><br/>
 This encapsulates the parameters of the model and the sufficient statistics that are necessary for inference </li>
<li>
<b><a class="el" href="class_model___refiner.html">Model_Refiner</a>:</b><br/>
 This encapsulates the logic needed for refining the initial model which involves streaming the documents from disk, sampling new topic assignments, updating the model, performing diagnostics and optimization and writing the documents back to disk </li>
<li>
<b><a class="el" href="class_pipeline.html" title="An interface that all pipeline objects must implement.">Pipeline</a>:</b><br/>
 As can be seen above, the refiner does a sequence of operations on every document of the corpus. Some of them have to run serially but some others can be run parallely. To enable exploiting multi-core parallelism, the <a class="el" href="class_pipeline.html" title="An interface that all pipeline objects must implement.">Pipeline</a> is defined to be composed of a set of operations called filters which can either be declared to be run serially or parallely. The <a class="el" href="class_pipeline.html" title="An interface that all pipeline objects must implement.">Pipeline</a> comes with a scheduler that schedules the threads available on the machine to run these filters in an optimal fashion </li>
<li>
<b><a class="el" href="class_execution___strategy.html" title="Interface for strategy objects.">Execution_Strategy</a>:</b><br/>
 This encapsulates the strategy that decides what filters a pipeline is composed of, how many times the documents are passed through the pipeline. </li>
</ol>
<h3><a class="anchor" id="builder">
Builder Pattern</a></h3>
<p>The Builder pattern fits very well for this approach. We implement a <a class="el" href="class_model___builder.html">Model_Builder</a> that builds the last three components depending on what model is needed and what mode the model is supposed to operate in.</p>
<p>The <a class="el" href="class_model___builder.html">Model_Builder</a> creates an initial <a class="el" href="class_model.html">Model</a> and creates the required <a class="el" href="class_model___refiner.html">Model_Refiner</a> by passing the Model(or the necessary components of the Model). It then creates a <a class="el" href="class_pipeline.html" title="An interface that all pipeline objects must implement.">Pipeline</a> and an <a class="el" href="class_execution___strategy.html" title="Interface for strategy objects.">Execution_Strategy</a> as per the mode of operation.</p>
<p>The Director is pretty straightforward. It directs the given <a class="el" href="class_model___builder.html">Model_Builder</a> to create the necessary components and executes the defined <a class="el" href="class_execution___strategy.html" title="Interface for strategy objects.">Execution_Strategy</a>. This refines the initial <a class="el" href="class_model.html">Model</a> created by the builder into one that reflects parameters tuned to the corpus on which the <a class="el" href="class_model.html">Model</a> was refined on. Then the <a class="el" href="class_model.html">Model</a> is stored on disk for testing.</p>
<h2><a class="anchor" id="multi-machine">
Distributed Set Up</a></h2>
<p>To cater to the Scalability goals, as detailed in <a href="http://portal.acm.org/citation.cfm?id=1920931">An Architecture for Parallel Topic Models</a>, the framework implements a Distributed Memory based multi-machine setup that exploits multi-machine parallelism to the fullest. The main idea being that the inferencing happens locally while the state variables are kept up-to-date with a global copy that stored using a Distributed HashTable. To come up with an efficient distributed set up is a difficult thing and we definitely do not want people reinvent the wheel here. So the framework tries to abstract the mechanism of distribution, the implementation of an efficient distributed HashTable and the mechanism needed for Synchrnoization.</p>
<h3><a class="anchor" id="distributed_map">
Distributed_Map</a></h3>
<p>The framework implements a Distributed_Map interface using Ice as a very efficient middleware. It essentially provides both a Server and <a class="el" href="class_client.html">Client</a> implementation. </p>
<ol>
<li>
<b><a class="el" href="class_d_m___server.html" title="The Server class that implements the DistributedMap Ice interface.">DM_Server</a>:</b><br/>
 The server essentially hosts a chunk of the distributed hash table and supports the usual map operations. It also supports three special operations: <ul>
<li>
Put: Which accumulates the values instead of replacing </li>
<li>
waitForAll: Which is a barrier implementation using AMD </li>
<li>
PutNGet: which is an asynchronous call that accumulates the passed value into the existing one and returns the final value back to the caller through a call back mechanism  </li>
</ul>
</li>
<li>
<b><a class="el" href="class_d_m___client.html" title="The client used to access the Distributed Map.">DM_Client</a>:</b> <br/>
 A client that supports a single hash table view of the distributed system. The client transparently supports a rate limited, sliding-window based Asynchronous Method Invocation for the PutNGet which is a very useful operation to have for effective Synchronization. Refer to the VLDB paper for more information.  </li>
</ol>
<p>For most models, one need not worry about modifying the above. These only need to be used most of the times without bothering much about their implementation.</p>
<h3><a class="anchor" id="synchronizer">
Synchronizer</a></h3>
<p>The framework provides a default implementation of the Synchronization strategy detailed in [2]. The <a class="el" href="class_synchronizer.html">Synchronizer</a> is run as a separate background thread apart from the main threads that do the inferencing. The actual task of synchronization is left to the implementation of a <a class="el" href="class_synchronizer___helper.html" title="A helper class for the synchronizer.">Synchronizer_Helper</a> class. The Sychronizer only creates slots for synchronization and asks the helper to synchronize in those slots. It also takes care of running the Synchronization only till the inferencing is done.</p>
<p>However, there is a strong assumption that the synchronization proceeds in a linear fashion. That is the structures being synchronized are linear and can be synchronized one after the other. This is implicit in the Synchronizer's creation of slots.</p>
<h3><a class="anchor" id="synchronizer_helper">
Synchronizer_Helper</a></h3>
<p>Every model has to only provide the <a class="el" href="class_synchronizer___helper.html" title="A helper class for the synchronizer.">Synchronizer_Helper</a> implementation which spills the logic for synchronizing the model's relevant structures, maintains copies of them where needed and provides the callback function for the AMI putNGet.</p>
<h2><a class="anchor" id="default_impl">
Default Implementations provided</a></h2>
<p>The framework provides default implementations for the <a class="el" href="class_pipeline.html" title="An interface that all pipeline objects must implement.">Pipeline</a> interface and the Execution_Stratgey interface. </p>
<ol>
<li>
<b><a class="el" href="class_t_b_b___pipeline.html">TBB_Pipeline</a>:</b><br/>
 This implementation uses Intel's Threading Building Blocks for providing the <a class="el" href="class_pipeline.html" title="An interface that all pipeline objects must implement.">Pipeline</a> interface. </li>
<li>
<b><a class="el" href="class_training___execution___strategy.html">Training_Execution_Strategy</a>:</b><br/>
 The default implementation of <a class="el" href="class_execution___strategy.html" title="Interface for strategy objects.">Execution_Strategy</a> for LDA training. Assembles the following pipeline for data flow: <div align="center">
<img src="data_flow.png" alt="data_flow.png"/>
</div>
  </li>
<li>
<b><a class="el" href="class_synchronized___training___execution___strategy.html" title="Default implementation of the Execution_Strategy interface.">Synchronized_Training_Execution_Strategy</a>:</b><br/>
 The default implementation of <a class="el" href="class_execution___strategy.html" title="Interface for strategy objects.">Execution_Strategy</a> that extends <a class="el" href="class_training___execution___strategy.html">Training_Execution_Strategy</a> and adds Synchronization capability </li>
<li>
<p class="startli"><b><a class="el" href="class_testing___execution___strategy.html">Testing_Execution_Strategy</a>:</b><br/>
 The default implementation of <a class="el" href="class_execution___strategy.html" title="Interface for strategy objects.">Execution_Strategy</a> for LDA testing.</p>
<p class="endli"></p>
</li>
</ol>
<h2><a class="anchor" id="unigram">
Unigram Model</a></h2>
<p>The framework also provides the <a class="el" href="class_unigram___model.html">Unigram_Model</a> implementations of the various common interfaces. This is the basic LDA model with the bag of words assumption. Please take a look at how the various interfaces are implemented. The main implementation needed is for <a class="el" href="class_model.html">Model</a> &amp; <a class="el" href="class_model___refiner.html">Model_Refiner</a>. Additionally, it implements efficient sparse data structures to store the sufficient statistics.</p>
<h2><a class="anchor" id="new_model">
Adding a new Model</a></h2>
<p>Please use the <a class="el" href="class_unigram___model.html">Unigram_Model</a> implementation as an example to implement new models</p>
<h2><a class="anchor" id="chkpt">
Checkpoints</a></h2>
<p>The framework also provide checkpointing functionality for the multi-machine setup in order to provide failure recovery. This is implemented by an external object that knows how to do three things: a. Serialize metadata to disk b. load previously serialized metadata on request c. Serialize the datastructures to disk</p>
<p>An appropriate checkpointer is passed as an argument while creating an <a class="el" href="class_execution___strategy.html" title="Interface for strategy objects.">Execution_Strategy</a> The strategy uses checkpointers to checkpoint at regular intervals. At startup, it also checks if any checkpoints are available and if so, it starts up from that checkpoint.</p>
<p>Different checkpointers are needed for different setups. For ex., the framework uses the Local <a class="el" href="class_checkpointer.html" title="Used to implement failure recovery.">Checkpointer</a> when running in single machine mode which only involves writing the iteration number as metadata. All other data needed for restart is already being serialized. However, for the multi-machine setup, a different mechanism is needed and a Hadoop <a class="el" href="class_checkpointer.html" title="Used to implement failure recovery.">Checkpointer</a> is implemented.</p>
<p>This is an ongoing effort and we will add more stuff both to the code and documentation. We definitely need your help &amp; contribution in making this better.</p>
<p>Here is an initial set of TODOs:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd><p class="startdd">Add unit tests to make the code more robust </p>
<p>Add more code documentation for the <a class="el" href="class_unigram___model.html">Unigram_Model</a> components </p>
<p>Implement fancier models in later versions </p>
<p class="enddd">Implement extensions to the LDA model in later versions</p>
</dd></dl>
<p>These are in no particular order and we might re-prioritize later. Please mail me if you are interested in contributing</p>
<p>We shall use the git pull request (fork + pull model) for collaborative development. </p>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Jul 14 12:04:32 2011 for Y!LDA by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
